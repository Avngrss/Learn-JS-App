<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Вопросы на собеседовании по JS</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,500;1,600&display=swap" rel="stylesheet" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg" style="background-color: #e3f2fd">
      <div class="container">
        <a class="navbar-brand" href="index.html">
          <img class="img-fluid" src="img/js.png" alt="JS" width="50" height="50" />
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
          <ul class="navbar-nav">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Методы </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="string.html">Строк</a></li>
                <li><a class="dropdown-item" href="array.html">Массивов</a></li>
                <li><a class="dropdown-item" href="#">Обьетов</a></li>
              </ul>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="js-sobesed.html" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Собеседование </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="js-sobesed.html">по языку JS</a></li>
                <li><a class="dropdown-item" href="Js-in-brouser.html">по браузерному JS</a></li>
                <li><a class="dropdown-item" href="js-async.html">по асинхронному JS</a></li>
                <li><a class="dropdown-item" href="react.html">React</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#"> Задачи </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <h1 class="font-bold">1.Типы данных в JS?</h1>
      <p>Всего 8 типов данных: string(строка), number(число), bigint, boollean, symbol, object(обьект), null, undefined</p>
      <h1 class="font-bold">2.Разница между == и ===?</h1>
      <p>Нестрогое просто сравнивает значение а строгое дополнительно сравнивает их типы</p>
      <h1 class="font-bold">3.Что такое Strict Mod в JS?</h1>
      <p>Позволяет использовать более строгий режим в синтаксисе языка. Он заменяет исключениями некоторые ошибки которые интерпритатор пропускает по умолчанию</p>
      <h1 class="font-bold">4.Function declaration и Function Expression?</h1>
      <p>Function declaratio функция созданная в основном потоке документа и начинается с ключенвого слова function. Function Expression это когда созданная функция присваивается в переменную.Function declaration создается до выполнения кода и ее можно вызвать еще до обьявления и это не вызывет ошибку происходит это из за всплытия</p>
      <h1 class="font-bold">5.Разница между null и undefined?</h1>
      <p>null это явное задание отсутсвующего значения. undefined по умолчанию присваивается для переменных, функций, несуществующих свойств обьетов которым еще не было присвоено какое либо значение</p>
      <h1 class="font-bold">6.Что такое "всплытие"(hosting)?</h1>
      <p>Это механизм поднятие функции или переменной в глобальную или функциональную область видимости это особенность движка JS. движок сначала обьявляет а потом инициализирует наши переменные а это значит что к переменным обьявленным через var и Function declaration применяется всплытие. Let и const не всплывают.</p>
      <h1 class="font-bold">7.Операторы "И" и "ИЛИ" (&& ||)?</h1>
      <p>"И" находит и возвращает первое ложное значение либо последний операнд когда все значения истинны</p>
      <code>
        console.log(false && 2023 && 'string') //false <br />
        console.log(2023 && {} && 'string') //'string' <br />
        console.log(true && null && 'string') //null</code
      >
      <p>"ИЛИ" находит и возвращает первое истинное значение</p>
      <code>
        console.log(false || 2023 || 'string') //2023 <br />
        console.log(2023 || false || 'string') //2023 <br />
        console.log(true && null && 'string') //null</code
      >
      <h1 class="font-bold">8.Типы таймеров в JS?</h1>
      <p>setTimeout позволяет вызвать переданную функцию один раз по истичении определенного времени. setInterval позволяет вызвать переданную функцию постоянно через определенный промежуток времени времени. таймеры принимают 2 значение это функция и количество милисекунд</p>
      <h1 class="font-bold">9.Что такое область видимости(Scope)?</h1>
      <p>
        Это место или область из которой мы имеем доступ к переменным или функциям. Есть три типа области видимости. Глобальная все переменные и функции становяться доступными из любого места в коде. Локальная(функциальная) переменные и функции доступны только этой функции и всем вложенным в нее функциям. Блочная такая область находится в нутри
        фигурных скобок переменные обьявленные через var на такую область не реагируют.
      </p>
      <h1 class="font-bold">10.Разница между var, const ,let?</h1>
      <p>Переменные через var всплывают. У них различные области видимости. У let и const область видимости ограничена блоком. Const нельзя изменять</p>
      <h1 class="font-bold">11.Что такое функции высшего порядка(Hugher Order Function)?</h1>
      <p>Это функции которые возвращают другие функции или принимает другую функцию в качестве аргумента. Например такие функции как map, reduce, filter, forEach и тд</p>
      <h1 class="font-bold">12.Что такое замыкание?</h1>
      <p>
        При создании функции и использовании внутри нее переменных эти переменные доступны только локально внутри функции. На храниее таких данных выделяется память и когда функция прекращает свое выполнение эта память очищается таким образом эти переменные больше ничде не существуют. Но если внутри функции создать другую функцию то вложенная
        функция полуит доступ к переменным которые были обьявлены во внешней функции. Проще говоря вложенная функция замыкает на себе переменные и аргументы внешней функции
      </p>
      <h1 class="font-bold">13.Что обозначает this в JS?</h1>
      <p>Это контекст вызова или ссылка на значение обьекта который выполняет или вызывает функцию.</p>
      <h1 class="font-bold">14.Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?</h1>
      <p>Использовать либо функцию Boollen() или использовать двойное отрицание !! . Ложные значение в JS это: '', 0, false, null, undefined, NaN</p>
      <h1 class="font-bold">15.Что такое чистая функция?</h1>
      <p>Это функция которая возвращает одинаковый результат когда вызывается с тем же набором аргументов</p>
      <h1 class="font-bold">16.Разница между .forEach() и .map()?</h1>
      <p>Это методы массива для перебора. forEach перебирает и ничего не возвращает а map перебирает и возвращает новый массив который можно использовать дальше.</p>
      <h1 class="font-bold">17.Разница между .call(), .apply() и bind()?</h1>
      <p>
        Иногда бывает что контекст вызова теряется и тогда мы можем пользоватсья данными функциями. Каждый аргумет в качестве первого аргумента принимает контекст вызова. Разница между call и apply в том как передаются аргументы внутрь функции. Для call это обычное перечисление через запятую, а apply аргументы нужно передовать через массив. Они
        применяются на месте и можно сразу получить результат, а bind создает функцию обертку которую можно присвоить в переменную
      </p>
      <h1 class="font-bold">18.Почему в JS функции называют объектами первого класса?</h1>
      <p>Все типы данных ведут себя как обьеты и у них есть методы которые можно использовать и функции не исключение</p>
      <h1 class="font-bold">19.Как определить наличие свойства в объекте?</h1>
      <p>
        Можно использовать hasOwnProperty
        <code>console.log(obj.hasOwnProperty(propertyKey))</code> <br />
        Использование оператора in
        <code>console.log('propertyKey' in obj)</code> <br />
        Индексная натация
        <code>console.log(obj["propertyKey"])</code> <br />
      </p>
      <h1 class="font-bold">20.Что такое IIFE?</h1>
      <p>
        Анонимная самовызывающая функция и такое выражение выполняется после создания
        <code>
          <br />
          (function() { <br />
          const greeting = 'Hello'; <br />
          console.log(greeting) <br />
          })();
        </code>
        <br />
        Данный патерн использовался для того чтобы не загрязнять глобальное пространство имен
      </p>
      <h1 class="font-bold">21. Что такое псевдомассив arguments?</h1>
      <p>Это коллекция аргументов которая передается в функцию. Это обьект подобный массиву и имеет только свойство lenght</p>
      <h1 class="font-bold">22. Разница между host-объектами и нативными объектами?</h1>
      <p>host-обьекты это обьекты которые предоставляются средой выполнения, браузером(window, document, location... e.g.). Нативные обьекты это обьеты которые являются састью языка JS(String, RegExp, function... e.g.)</p>
      <h1 class="font-bold">23. Почему результат сравнения 2х объектов это false?</h1>
      <p>Обьекты сравниваются по ссылке или адресу в памяти. А ссылки у них разные поэтому это false</p>
      <h1 class="font-bold">24. Что такое прототипное наследование? Как создать объект без прототипа?</h1>
      <p>
        Все обьекты имеют свойство prototype которое является ссылкой на другой обьект. Когда к свойству происходит обращение и если свойство не находится в текущем обьекте то JS просматривает прототип обьекта и ищет это свойство там затем он идет в прототип прототипа пока не достигнет конца цепочки. Чтобы создать обьект без прототипа нужно
        использовать <code>Object.create(null)</code>
      </p>
      <h1 class="font-bold">25. Почему расширение нативных JavaScript-объектов это плохая практика?</h1>
      <p>Расширение нативного обьекта означает добавление новых свойств что ведет к конфликту с его прототипом и может нарушить логику работы(например при использовании сторонних библиотек)</p>
      <h1 class="font-bold">26. Что такое NaN? Как определить, что значение равно NaN?</h1>
      <p>NaN расшифровывается как НЕ ЧИСЛО и срабатывает когда математическая функция сработала не верно а для проверки используется isNaN() и результатом возвращет true или false</p>
      <h1 class="font-bold">27. Как в JavaScript создать объект??</h1>
      <p>
        Через обьектный литерал
        <code
          >const person = { <br />
          name:"Lol" <br />
          } <br
        /></code>
        Через функцию конструктор и Метод Object.create()
      </p>
      <h1 class="font-bold">28. Для чего используется ключевое слово new?</h1>
      <p>Используется для создания нового обьекта точнее экземпляра класса</p>
      <h1 class="font-bold">29. Для чего используется оператор двойного отрицания (!!)?</h1>
      <p>Для приведения типа к Boolean</p>
      <h1 class="font-bold">30. Для чего используется оператор остатка (%)?</h1>
      <p>Для проверки на кратность</p>
      <h1 class="font-bold">31. Как проверить, является ли значение массивом?</h1>
      <p>Использовать функцию Array.isArray()</p>
      <h1 class="font-bold">32. Разница между оператором in и методом .hasOwnProperty()?</h1>
      <p>in проверяет свойства не только в обьекте но и в его прототипе</p>
      <h1 class="font-bold">33. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?</h1>
      <p>Для поверхностного копирование достаточно присвоить обьект в новую переменную. Для глубокого копирования можно использовать spread оператор , Object.assine({}, car1)</p>
      <h1 class="font-bold">34. Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?</h1>
      <p>Цепочка вызовов это когда методы вызываются один за одним без дополнительного обращения к исходному обьекту</p>
      <h1 class="font-bold">35. Что такое необъявленная переменная?</h1>
      <p>Это переменные не обьявленные черз var let const</p>
      <h1 class="font-bold">36. Как передаются параметры в функцию: по ссылке или по значению?</h1>
      <p>параметры которые передаются в функцию всегда передаются по значению</p>
      <h1 class="font-bold">37. Как работает метод Object.create()?</h1>
      <p>Это самый простой способ наследования одного обьекта от другого без вызова функции конструктора</p>
      <h1 class="font-bold">38. Разниц между Object.freeze() и Object.seal()?</h1>
      <p>Object.seal() предотвращает удаление или добавление свойства в защищенный обьект Object.freeze() + защищает от изменений уже существующий свойст</p>
      <h1 class="font-bold">39. Разница между методами .slice() и .splice()?</h1>
      <p>.slice() возвращает неглубокую копию массива начиная с начального индекса и конечного, а если указаьб только начала то вернет весь массив. splice() меняет содержимое массива, удаляет существующие элементы или заменяя их на другие. Он модифицирует исходный массив</p>
      <h1 class="font-bold">40. Как работают методы .find(), .findIndex() и .indexOf()?</h1>
      <p>Все три метода используются для поиска элементов в массиве. find() возвращает первый элемент который подходит под условие. findIndex() возвращает индекс элемента который подходит под условие. indexOf() принимет значние необходимого элемента</p>
      <h1 class="font-bold">41. Плюсы и минусы использования use strict?</h1>
      <p>Плюсы</p>
      <ul>
        <li>Не позволяет случайно создавать глобальные переменные</li>
        <li>Любое присваивание которое в обычном режиме завершится неудачей в строгом режиме выдаст исключение</li>
        <li>this в глобальной области видимости рано undefined</li>
        <li>Перехватывает распространненые ошибки выдавая исключения</li>
        <li>Исключает неочевидные особенности языка</li>
      </ul>
      <p>Минусы</p>
      <ul>
        <li>Нельзя использывать некоторые особенности языка</li>
        <li>Обьединение скриптов в строгом режиме может вызвать проблемы</li>
      </ul>
      <h1 class="font-bold">42. Разница между методами .push(), .pop(), .shift() и .unshift()?</h1>
      <p>Все четыре метода используются для работы с массивом. Они либо дабавляют либо удаляют элементы в массиве.push() добаляет в конец массива, .pop() удаляет с конца массива, .shift() удаляет первый элемент,.unshift() добаляет элемент в начало массива</p>
      <h1 class="font-bold">43. Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?</h1>
      <p>Иммутабельность это как и неизменяемый обьект</p>
      <p>Плюсы</p>
      <ul>
        <li>Простое и быстрое отслеживание изменений</li>
        <li>Более безопастное использование и тестирование</li>
        <li>Разный уровень производительности зависящий от конкретной реализации структур данных с которыми ведется работа</li>
      </ul>
      <p>Минусы</p>
      <ul>
        <li>Разный уровень производительности зависящий от конкретной реализации структур данных с которыми ведется работа</li>
      </ul>
      <p>Иммутабельности можно допиться используя const и Object.freeze()</p>
      <h1 class="font-bold">44. Типы всплывающих окон в JavaScript?</h1>
      <p>Alert() выводит диалоговое окно с кнопкой OK может служить для уведомления что что то произошло</p>
      <p>Confirm() выводит диалоговое окно с кнопкой OK и Cansel может служить для подтверждения и отклонения</p>
      <p>Promt() выводит диалоговое окно с кнопкой OK и Cansel bи полем ввода может служить для получения дополнительной информации</p>
      <h1 class="font-bold">45. Типы объектов JavaScript?</h1>
      <ul>
        <li>Обьект массива</li>
        <li>Строковый обьект</li>
        <li>Обьект даты</li>
        <li>Числовой обьект</li>
        <li>Функциальный обьект</li>
        <li>Логический обьект</li>
        <li>Обьект Math</li>
        <li>Обьект RegExp</li>
        <li>Обьект Object</li>
      </ul>
      <h1 class="font-bold">44. Парадигмы программирования в JavaScript?</h1>
      <p>ООП</p>
      <p>Наследование, Инкапсуляция, Полиморфизм, Абстракция</p>
      <p>Функциональное программирование</p>
      <p>Чистые функции, иммутабельность, ссылочная прозрачность, замыкания, функции первого класса, функции высшего порядка</p>
      <h1 class="font-bold">44. Типы ошибок в JavaScript?</h1>
      <p>Ошибки времени загрузки - ошибки возникащие во время загрузки страницы</p>
      <p>Ошибки времени выполнения - ошибки возникащие при не правильном использовании команды внутри HTML</p>
      <p>Логические ошибки - ошибки возникащие при неправильной логике в операциях</p>
      <ul>
        <li>RangeError - происходит когда число не попадает в диапозон</li>
        <li>ReferenceError - ошибка ссылки когда логика ссылкается на несуществующий элемент в коде</li>
        <li>SyntaxError - синтаксическая ошибка</li>
        <li>TypeError - ошибка при использовании в логике неверного типа</li>
      </ul>
      <h1 class="font-bold">45.JavaScript статически, или динамически типизированный язык?</h1>
      <p>JS это язык с динамической типизацией. С более слабой динамической типизацией это значит что переменная может быть любого типа</p>
      <h1 class="font-bold">46.Что такое регулярное выражение (Regular Expression)?</h1>
      <p>
        Регулярные выражения это шаблоны используемые для сопастовления последовательности символов в строках. Явлляется обьектом. Создать можно 2 способами литералами регулярного выражения или конструктором<br />
        <code>let re = /ab+c/g</code>
        <code>let re = new RegExp('ab+c', 'g')</code>
      </p>
      <h1 class="font-bold">47. Что такое рекурсия?</h1>
      <p>Функция в своем теле вызывает саму себя</p>
      <h1 class="font-bold">48. Что такое прототип (Prototype) объекта?</h1>
      <p>Проще говоря это план обьекта используется как резерв для свойств и методов</p>
      <h1 class="font-bold">49. Что такое полифил (polyfill)?</h1>
      <p>По факту это блок кода который выполняет логику для которой был написан. Используютя для обеспечения работы JS в старых браузерах</p>
      <h1 class="font-bold">50. Что такое switch/case? Правила использования switch/case?</h1>
      <p>
        Альтернатива if else и предствляет собой более наглядный способ выполнения кода в зависимости от переданного условия. switch сравнивает выражение со случаями перечисленными внутри нее а затем выполняет соответсвующие инструкции. Каждый случай отделен словом case где описывается логика и в конце узакзывается break для прекращения проверок
        если одна из них сработала дальше указывается default если ни одно условие не подошло. Условие должно быть строкой или числом, недопускается дублирование значений
      </p>
      <h1 class="font-bold">51. Типы функций по способности принимать другие функции?</h1>
      <p>Функция первого порядка, функция высшего порядка, унараная функция</p>
      <h1 class="font-bold">52. Что такое выражения (expression) и инструкции (statement) в JavaScript?</h1>
      <p>expression(выражения) это некоторые фрагменты кода которые приводят к выполнению и возврату некоторого значения</p>
      <p>statement(инструкция) это некоторые фрагменты кода которые выполняют какое то определенное действие(примеры: if else, switch, while, for)</p>
      <h1 class="font-bold">53. Разница между .some() и .every()?</h1>
      <p>Оба метода предназначены для перебора массива. some() перебирает массив и смотрит соотвествует ли один конкретный элемент в массиве логическому условию, every() соотвествует ли все элементы в массиве логическому условию</p>
      <h1 class="font-bold">54. Как сгенерировать случайное число в JavaScript?</h1>
      <p>Math.random()</p>
      <h1 class="font-bold">55. Типы операторов в JavaScript?</h1>
      <ul>
        <li>Операторы присваивания - x=y, x+=y</li>
        <li>Операторы сравнения - x==y, x===y, x!=y</li>
        <li>Арифмитические операторы - x+y, x*y, x-y</li>
        <li>Битовые операторы - x&y, x|y</li>
        <li>Логические операторы - x&&y, x||y</li>
        <li>Строковый операторы - "test" + "test1"</li>
        <li>тернарный оператор - condition ? x:y</li>
        <li>Оператор запятая - let x = 0, y = 1</li>
        <li>Унарный оператор - delete x, typeof y</li>
        <li>Операторы отношения - x in y, y instance y</li>
        <li>Оператор нулевого слияния - x??y</li>
      </ul>
      <h1 class="font-bold">56. Разница между параметром и аргументом функции?</h1>
      <p>Параметры это переменные которые используются при создании функции т.е. переменная указаная в круглых скобках при ее обьявлении. А аргументы функции это значения которые передаются ей при ее вызове</p>
      <h1 class="font-bold">57. Правила задания имён для переменных и функций в JavaScript?</h1>
      <p>Имя переменной должно содержать только буквы, цифры, или символы $ и _ . Первый символ не должен быть цифрой. А для функций должно быть название отображающие действие и написано в camelCase</p>
      <h1 class="font-bold">58. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?</h1>
      <p>Явное преобразование просходит при участии разработчика и с использованием специальных команд например ParseInt или number. А неявное преобразование происходит без участия разработчика например при сложении числа и строки</p>
      <p>Неявное преобразование</p>
      <code>console.log(1 + "6") //16</code> <br />
      <code>console.log(6 * "2") //12</code> <br />
      <p>Явное преобразование</p>
      <code>console.log(1 + parseInt("6")) //7</code> <br />
      <code>console.log(6 + number("2")) //8</code>
      <h1 class="font-bold">59. Для чего применяется метод Array.from()?</h1>
      <p>Создает новый массив на основе переданного обьекта. Обьект должен быть псевдомассивом (например строка) или итерируемым(коллекции Set или Map). Принимает 3 аргумента - это обьект и два опциональных. Можно передать функцию чтобы поработать с его элементами перед добавлением она похожа на Map</p>
      <h1 class="font-bold">60. Назовите способы преобразования массива в объект?</h1>
      <code>const arr = [1,2,3]</code>
      <ul>
        <li><code>const obj = Object.assign({}, arr)</code></li>
        <li><code>const obj = {...arr}(spread оператор)</code></li>
        <li><code>const obj = arr.reduce((res, key, i) => {res[i] = key; return key}, {})</code></li>
      </ul>
      <h1 class="font-bold">61. Что такое каррирование?</h1>
      <p>Это процесс преобразования функции с несколькики аргументами в последовательность функций каждая из которых имеет только один аргумент</p>
      <h1 class="font-bold">62. Для чего используются метод Object.seal()?</h1>
      <p>метод Object.seal() запечатывает обьект, предотвращает добавление новых свойств и делает все существующие свойства ненасстраивыми. И оператор delete вернет delete</p>
      <h1 class="font-bold">63. Для чего используется свойство .dataset?</h1>
      <p>Позволяет считывать или устанавливать любые data атрибуты на HTML элементы. Это пользовательский атрибут начинающийся в data-. Используюся чтобы хранить значение на элементе в HTML. Обращение происходит через .dataset</p>
      <h1 class="font-bold">64. Каким образом можно обмениваться кодом между файлами?</h1>
      <p>Через модули. Используя export и import</p>
      <h1 class="font-bold">65. Как работает «сборщик мусора» в JavaScript?</h1>
      <p>Большая часть алгоритмов сборки мусора основана на понятии ссылки. Это наиболее примитивный алгоритм сборки мусора, сужающий понятие "объект более не нужен" до "для данного объекта более нет ни одного объекта, ссылающегося на него". Объект считается подлежащим уничтожению сборщиком мусора, если количество ссылок на него равно нулю.</p>
      <h1 class="font-bold">66. Что такое утечки памяти?</h1>
      <p>Утечки памяти происходят, когда браузер по какой-то причине не может освободить память от недостижимых объектов. Можно сказать что это фрагменты памяти которые больше не нужны приложению но по какой то причине не возвращенной ОС. В JS есть автоматический сборщик мусора который следит за данной процедурой.</p>
      <h1 class="font-bold">67. Назовите основные типы утечек памяти в JavaScript?</h1>
      <ul>
        <li>Глобальные переменные(Чтобы избежать можно добавить usestrick)</li>
        <li>Таймеры или забытые колбэки(таймеры не поддвергаются сборке мусора. Поэтому нужно не забывать отключать таймеры через clearInterval)</li>
        <li>Замыкания(Чтобы избежать утечки памяти нужно правильно использовать механизм замыкания)</li>
        <li>Сылки на обьекты DOM за пределами DOM</li>
      </ul>
      <h1 class="font-bold">68. Как работает контекст выполнения (execution context) в JavaScript?</h1>
      <p>контекст выполнения это абстрактное понятие которое описывает окружение в котором выполняется код. Он состоит из 3 основных компонентов</p>
      <ul>
        <li>Глобальный контекст выполнения - это первоначальный контекст создаваемый при запуске скрипта. В нем определятся глобальные переменные, функции и другие глобальные обьекты</li>
        <li>Контекст выполнения функции - создается при ее вызове, в нем определяется локальные переменные функции, параметры, область видимости</li>
        <li>Контекст выполнения eval - там определяюся все переменные и обьеты созданные в результате ее выполнения</li>
      </ul>
      <p>Весь контекст выполнения образует стек вызова(call stack). При вызове функции весь контескт вызова помещается на верх стека а после выполнения удаляется</p>
      <h1 class="font-bold">69. Разница между примитивом и объектом?</h1>
      <p>Примитивы представляют собой базовые примитивы (числа строки null undefined и тд) Они хранятся в переменной или передаются по значению и имеют фиксированное значение, а обьекты являются сложными структурами данных и служат для хранения коллекций свойст и методов. Обьекты передаются по ссылке которая не является копией</p>
      <h1 class="font-bold">70. Разница между Rest и Spread операторами?</h1>
      <p>Операторы легко отличить. Когда синтаксис ... используется для «распаковки» элементов массива или объекта в отдельные аргументы — это spread. А если три точки используются для сбора оставшихся аргументов в массив или объект — это оператор rest.</p>
      <h1 class="font-bold">71. Что такое деструктуризация?</h1>
      <p>Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.</p>
      <code
        >let [firstName, lastName] = ["Илья", "Кантор"]; <br />
        alert(firstName); // Илья <br />
        alert(lastName); // Кантор</code
      >
    </div>
    <h1 class="font-bold">72. Для чего используется цикл for…of?</h1>
    <p>Цикл for...of в JavaScript позволяет перебирать итерируемые объекты: массивы, множества, Map, строки и т.д.</p>
    <h1 class="font-bold">73. Расскажите о методах .keys(), .values(), .entries()?</h1>
    <p>Для простых объектов доступны следующие методы: Object.keys(obj) – возвращает массив ключей. Object.values(obj) – возвращает массив значений. Object.entries(obj) – возвращает массив пар [ключ, значение]</p>
    <script src="app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>

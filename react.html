<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,500;1,600&display=swap" rel="stylesheet" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg" style="background-color: #e3f2fd">
      <div class="container">
        <a class="navbar-brand" href="index.html">
          <img class="img-fluid" src="img/js.png" alt="JS" width="50" height="50" />
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
          <ul class="navbar-nav">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Методы </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="string.html">Строк</a></li>
                <li><a class="dropdown-item" href="array.html">Массивов</a></li>
                <li><a class="dropdown-item" href="#">Обьетов</a></li>
              </ul>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="js-sobesed.html" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Собеседование </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="js-sobesed.html">по языку JS</a></li>
                <li><a class="dropdown-item" href="Js-in-brouser.html">по браузерному JS</a></li>
                <li><a class="dropdown-item" href="js-async.html">по асинхронному JS</a></li>
                <li><a class="dropdown-item" href="react.html">React</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#"> Задачи </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <h1 class="font-bold">1.Что такое React?</h1>
      <p>React — это JavaScript-библиотека для создания пользовательских интерфейсов.</p>
      <h1 class="font-bold">2.Перечислите особенности React?</h1>
      <ul>
        <li>Универсальность.Одно из главных преимуществ библиотеки в том, что её можно использовать где угодно. К примеру, на своём сервере при создании нестандартных веб-сайтов, которые сложно реализовать на базе готовых систем управления контентом.</li>
        <li>
          Компонентность. Ещё одна отличительная особенность React — компонентный подход, который проявляется в использовании «строительных» единиц — компонентов. Шаблонов, контроллеров и других элементов нет, зато есть компоненты, которыми можно управлять. Компонент — что-то вроде бетонных блоков, из которых можно построить любое здание.
          Компоненты могут наследовать друг от друга свойства, их можно объединять между собой и использовать повторно.
        </li>
        <li>
          Виртуальный DOM. Важной особенностью библиотеки React является виртуальный DOM. Это объект, в котором содержится информация о состоянии интерфейса. К примеру, после того, как пользователь отправляет данные в форме на сервер, React определяет изменение состояния и обновляет внешний вид интерфейса. Таким образом, виртуальный DOM позволяет
          обновлять реальный DOM и без задержки менять состояние компонентов на экране. Пользователь не видит миганий и других визуальных артефактов.
        </li>
        <li>
          Расширение JSX.Расширение синтаксиса JavaScript походит на HTML, но это JS. Главная особенность заключается в том, что можно писать код с помощью готовых компонентов. Такой подход позволяет ускорить разработку. Библиотеку можно использовать и без JSX, но большинство разработчиков задействуют расширение, чтобы обеспечить наглядное
          взаимодействие с интерфейсом. Одно из главных преимуществ JSX — нативные уведомления об ошибках и предупреждения, которые помогают оперативно узнать о ситуациях, на которые стоит обратить внимание.
        </li>
      </ul>
      <h1 class="font-bold">3.Что такое Virtual DOM? Как он работает с React?</h1>
      <p>Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM.</p>
      <p>
        Когда в UI добавляются новые элементы, создается VDOM в виде дерева. Каждый элемент является узлом этого дерева. При изменении состояния любого элемента, создается новое дерево. Затем это новое дерево сравнивается (diffed) со старым. После этого вычисляется наиболее эффективный метод внесения изменений в RDOM. Цель данных вычислений состоит
        в минимизации количества операций, совершаемых с RDOM. Тем самым, уменьшаются накладные расходы, связанные с обновлением RDOM.
      </p>
      <h1 class="font-bold">4.Для чего нужен атрибут key при рендере списков?</h1>
      <p>
        Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени и помочь библиотеке точно определить то место где было изменение. Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от
        его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи
      </p>
      <h1 class="font-bold">5.Что такое PureComponent?</h1>
      <p>
        Чистые компоненты (pure components) - это компоненты, которые не рендерятся повторно при обновлении их состояния или пропов одними и теми же значениями. Если значение предыдущего и нового состояния и пропов равны, компонент не повторно отрисовывается. Чистые компоненты ограничивают повторный рендеринг, обеспечивая повышение
        производительности приложения.
      </p>
      <h1 class="font-bold">6.Что такое Компонент высшего порядка (Higher-Order Component/HOC)?</h1>
      <p>
        Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов. Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.Если
        обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.
      </p>
      <h1 class="font-bold">7.Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?</h1>
      <p>
        Элемент называется управляемым, если его значение контролирует React. Эта тема связана с такими HTML элементами как input, textarea, select. Обычно эти элементы сами управляют своим состоянием и сами обновляются когда пользователь вводит данные. Это неуправляемые компоненты - они хранят свои данные прямо в DOM. Чтобы прочитать их значения,
        используются рефы. Для того чтобы сделать управляемый компонент, нужно чтобы значение этих элементов хранилось именно в состоянии React компонента, т.е. управлялось через setState/useState, таким образом состояние React-компонента становится единственным источником правды для этих элементов.
      </p>
      <h1 class="font-bold">8. Методы жизненного цикла компонента в React?</h1>
      <p>Метод render() — единственный обязательный методов в классовом компоненте.</p>
      <p>constructor() Если вы не инициализируете состояние и не привязываете методы, вам не нужно реализовывать конструктор в вашем React-компоненте.</p>
      <p>componentDidMount() вызывается сразу после монтирования компонента (вставлено в DOM-дерево). Инициализация, требующая DOM-узлов, должна быть здесь. Если вам нужно загружать данные с удалённой конечной точки (endpoint), это хорошее место для создания экземпляра сетевого запроса.</p>
      <p>componentDidUpdate() вызывается сразу после обновления. Этот метод не вызывается при первоначальной отрисовке.</p>
      <p>componentWillUnmount() вызывается непосредственно перед размонтированием и уничтожением компонента. Выполните необходимую очистку в этом методе, такую как отмена таймеров, сетевых запросов или очистка любых подписок, созданных в componentDidMount().</p>
      <h1 class="font-bold">9. Стадии жизненного цикла компонента в React?</h1>
      <p>Каждый компонент React проходит несколько стадий в процессе своей жизни: он создается, затем добавляется в DOM, получает пропсы, и, наконец, удаляется из дерева. Этот процесс называют жизненным циклом компонента (Component Lifecycle).</p>
      <p class="fw-bold">Монтирование (Mounting) - Эти методы вызываются по порядку во время создания объекта и вставки его в DOM.</p>
      <p>constructor() static getDerivedStateFromProps() render() componentDidMount()</p>
      <p class="fw-bold">Обновление (Updating) Обновление может происходить при изменении свойств или состояния. Эти методы вызываются по порядку во время перерисовки:</p>
      <p>static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate()</p>
      <p class="fw-bold">Удаление или демонтирование (Unmounting)</p>
      <h1 class="font-bold">9. Что такое React Reconciliation?</h1>
      <p>Сверка — это алгоритм React, используемый для того, чтобы отличить одно дерево елементов от другого для определения частей, которые нужно будет заменить. Апдейт — это изменение в данных, которые используются для отрисовки React приложения.</p>
      <h1 class="font-bold">10. Что такое портал (Portal)?</h1>
      <p>
        Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие
        карточки и всплывающие подсказки.
      </p>
      <h1 class="font-bold">11. Что такое контекст (Context)?</h1>
      <p>
        Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях. В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, подобный способ использования может быть чересчур громоздким для некоторых типов пропсов
        (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева
      </p>
      <h1 class="font-bold">12. Что такое React хуки (Hooks)?</h1>
      <p>
        Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.Хуки — механизм в React, который позволяет работать полностью без классов. Он не приносит ничего нового, но облегчает повторное использование кода для решения общих задач. Сейчас это основной способ написания
        React-приложений.
      </p>
      <h1 class="font-bold">13. Что Такое JSX?</h1>
      <p>JSX позволяет создавать HTML-элементы прямо в JavaScript и помещать их в DOM без использования таких методов, как createElement или appendChild. JSX преобразует HTML-теги в элементы React. React использует JSX для шаблонизации вместо обычного JavaScript.</p>
      <h1 class="font-bold">14. Разница между состоянием(state) и пропсами(props)?</h1>
      <p>
        props (намеренно сокращённо от англ. «properties» — свойства) и state — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: props передаётся в компонент (служат как параметры функции), в то время как state находится внутри компонента (по
        аналогии с переменными, которые объявлены внутри функции).
      </p>
      <h1 class="font-bold">15. Что такое React Fiber?</h1>
      <p>React Fiber — прогрессивная реализация ключевого алгоритма React. Это кульминационное достижение двухгодичных исследований команды разработчиков React. Цель Fiber в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов.</p>
      <h1 class="font-bold">16. Что такое фрагмент (Fragment)? Почему фрагмент лучше, чем div?</h1>
      <p>Fragments позволяют писать более чистый, читаемый и поддерживаемый код. Они не заменяют div в вашем HTML, но они предлагают лучший подход к структурированию и рендерингу вашей разметки, если вы используете ненужные divв своем коде.</p>
      <h1 class="font-bold">17. Что такое синтетические события в React?</h1>
      <p>Ваши обработчики событий получают экземпляр SyntheticEvent , это кроссбраузерная обёртка над нативным экземпляром события. У неё такой же интерфейс, как и у нативного события, включая методы stopPropagation() и preventDefault() . Эта обёртка помогает событиям работать одинаково во всех браузерах.</p>
      <h1 class="font-bold">18. Что такое React-ссылка (ref)? Как создать ссылку?</h1>
      <p>
        Refs (далее просто «ссылки») предоставляет способ доступа к DOM-узлам или React-элементам, созданным в методе render(). В обычном потоке данных React свойства — единственный способ взаимодействия родительских компонентов со своими дочерними элементами. Чтобы изменить дочерний элемент, вы повторно отрисовываете его с помощью новых свойств.
        Тем не менее, есть несколько случаев, когда вам необходимо принудительно модифицировать дочерний элемент за пределами типичного потока данных. Изменяемый дочерний элемент может быть экземпляром компонента React или DOM-элементом. Для обоих этих случаев React предоставляет запасной вариант.refs используются для получения ссылки на узел DOM
        (Document Object Model) или компонента в React. Если кратко, то Refs возвращает ссылку на элемент.Ссылки создаются с использованием React.createRef() и добавляются к React-элементам с помощью атрибута ref. Ссылки обычно присваиваются свойству экземпляра, когда компонент создаётся таким образом, чтобы на них можно было ссылаться по всему
        компоненту.
      </p>
      <h1 class="font-bold">19. Разница между теневым (Shadow) и виртуальным (Virtual) DOM?</h1>
      <p>Нет, они совсем разные. Теневой DOM (Shadow DOM) — это браузерная технология, предназначенная в основном для определения области видимости переменных и CSS в веб-компонентах. Виртуальный DOM — это концепция, реализованная библиотеками в JavaScript поверх API браузера.</p>
      <h1 class="font-bold">20. Назовите преимущества использования React?</h1>
      <p>У React четыре преимущества перед аналогичными библиотеками для разработки интерфейсов.</p>
      <ul>
        <li>Универсальность. React — это JavaScript-библиотека, а JavaScript — популярный язык программирования, который используется всюду. Ни одна другая JS-библиотека не работает в таком количестве окружений и на таком количестве устройств.</li>
        <li>Гибкость. React гибкий, потому что позволяет: выбирать, какие библиотеки использовать, например, для контроля за переходами между экранами и хранения данных; менять инструменты разработки; сделать приложение полностью на React; или использовать его для одной фишки. Выбирать вам.</li>
        <li>Отличный DevX. UX — это пользовательский опыт, а DevX — опыт разработчика — то, насколько удобно, комфортно и просто разработчику взаимодействовать с технологией. И у React отличный DevX.</li>
        <li>Читаемость. В React приложение разбито на компоненты, поэтому в 9 случаях из 10 при поломке видно, в какой части кода беда:</li>
      </ul>
      <h1 class="font-bold">21. Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?</h1>
      <p>
        ВУсловная отрисовка в React работает так же, как условия работы в JavaScript. Используйте JavaScript-операторы, например if или тернарный оператор, чтобы создать элементы, представляющие текущее состояние, и пусть React обновит пользовательский интерфейс для соответствия им.Вы можете вставлять любые выражения в JSX, обёртывания их фигурными
        скобками. Это включает логический JavaScript-оператор &&. Это может быть удобно для условной отрисовки элемента:
      </p>
      <h1 class="font-bold">22. Что такое компонент-переключатель (Switching Component)?</h1>
      <p>Switching Component это компонент который редерит один из нескольких компонентов. Это своеобразный react паттерн который позволят реализовать удобный механизм отримовки нескольких компонентов на основании какого-либо условия</p>
      <h1 class="font-bold">23. Разница между React и ReactDOM?</h1>
      <p>React — это библиотека JavaScript для создания пользовательских интерфейсов, а ReactDOM — это библиотека JavaScript, которая позволяет React взаимодействовать с DOM.</p>
      <h1 class="font-bold">24. Как React обрабатывает, или ограничивает использование пропсов определенного типа?</h1>
      <p>PropTypes - хороший способ перехвата ошибок, связанных с неправильными типами props. PropTypes позволяет помечать пропы как обязательные или определять их значения по умолчанию.</p>
      <p>PropTypes определяет тип пропа. Каждый раз, когда через проп передается какое-либо значение, оно проверяется на правильный тип. Если будет обнаружен неправильный тип, в консоль будет выведено сообщение об ошибке.</p>
      <h1 class="font-bold">25. Что такое строгий режим в React? Его преимущества?</h1>
      <p>StrictMode — инструмент для обнаружения потенциальных проблем в приложении. Также как и Fragment, StrictMode не рендерит видимого UI. Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.</p>
      <ul>
        <li>Обнаружение небезопасных методов жизненного цикла</li>
        <li>Предупреждение об использовании устаревшего API строковых реф</li>
        <li>Предупреждение об использовании устаревшего метода findDOMNode</li>
        <li>Обнаружение неожиданных побочных эффектов</li>
        <li>Обнаружение устаревшего API контекста</li>
      </ul>
      <h1 class="font-bold">26. Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?</h1>
      <p>
        В React пропы передаются в одном направлении, сверху вниз, от родительского компонента к дочернему, и последовательно. При наличии незначительного количества пропов или потомков - это не является проблемой. Однако при росте приложения для того, чтобы передать пропы с верхнего уровня приложения компонентам, находящимся на 3 или 4 уровне
        вложенности, нам приходится передавать одни и те же пропы на каждом уровне дерева компонентов. Это называется бурением пропов (prop drilling). Context API Контекст решает некоторые проблемы, связанные с "бурением". Он позволяет компонентам получать данные на любом уровне без их передачи в виде пропов. Передаваемыми данными может быть что
        угодно: состояние, функция, объект и т.д. Эти данные доступны любым вложенным компонентам в пределах области видимости контекста.
      </p>
      <h1 class="font-bold">27. Разница между элементом и компонентом?</h1>
      <p>
        Компонент (component) - это шаблон. Проект или схема (blueprint). Глобальное определение. Он может быть функцией или классом (с методом рендеринга). <br />
        Элемент (element) - это то, что возвращается из компонента. Это объект, описывающий виртуальное представление определенного узла DOM, содержащегося в компоненте. В случае с функциональными компонентами, указанный объект возвращается функцией. В классовых компонентах объект возвращается методом render. Элементы React - это не то, что мы
        видим в браузере. Это всего лишь объекты, хранящиеся в памяти, мы не можем их изменять.Элемент - это обычный JavaScript-объект с определенными методами. Он имеет 4 свойства: type - строковое представление HTML-тега или ссылка на React-компонент; key - строка-идентификатор React-элемента; ref - ссылка на нижележащий узел DOM или экземпляр
        компонента React; props - объект со свойствами.
      </p>
      <h1 class="font-bold">28. Что такое ReactDOMServer?</h1>
      <p>Объект ReactDOMServer позволяет рендерить компоненты в виде статической разметки. Обычно, данный объект используется на Node.js-серверах:</p>
      <h1 class="font-bold">29. Что такое предохранители (Error Boundaries)?</h1>
      <p>
        Предохранители (error boundaries) - это React-компоненты, которые перехватывают любые ошибки, возникающие в дереве потомков, выводят сообщения об ошибках в консоль и отображают резервный UI вместо "сломанного". Предохранители перехватывают ошибки во время рендеринга, в методах жизненного цикла и в конструкторах дочерних компонентов.
        Классовый компонент становится предохранителем, когда в нем определяются методы жизненного цикла static getDerivedStateFromError или componentDidCatch (один или оба). static getDerivedStateFromError() используется для рендеринга резервного UI после возникновения ошибки. componentDidCatch() используется для обработки ошибки.
      </p>
      <h1 class="font-bold">30. Что такое «ленивая» (Lazy) функция?</h1>
      <p>
        React.lazy() позволяет создавать компоненты, загружаемые с помощью динамического import(), которые рендерятся как обычные компоненты. Это уменьшает размер "бандла" (кусок кода, отвечающий за определенную часть приложения), поскольку загружаются только те компоненты, которые отображаются на экране в данный момент. React.lazy() принимает
        функцию в качестве аргумента, которая возвращает промис в результате вызова import() для загрузки компонента. Модуль "разрешается" модулем с "дефолтным" экспортом, содержащим React-компонент.
      </p>
      <h1 class="font-bold">31. Разница между рендерингом и монтированием?</h1>
      <p>
        Рендеринг - это функция или метод render, вызываемый компонентом, возвращающие инструкции для создания DOM. Метод render вызывается при каждом рендеринге компонента. Обновление компонента происходит при изменении его state или props. Монтирование - это первый рендеринг компонента и построение первоначальной объектной модели документа
        (виртуального DOM). Монтирование компонента означает встраивание создаваемых им элементов в браузерный DOM. Повторный рендеринг - это повторный вызов функции для получения информации об уже смонтированном компоненте.
      </p>
      <h1 class="font-bold">32. Что такое сhildren?</h1>
      <p>
        children ссылается на контейнер, содержимое которого неизвестно до передачи данных из родительского компонента. Этот контейнер позволяет передавать компоненты другим компонентам в качестве данных подобно любому другому пропу. Отличительной особенностью children является то, что React предоставляет его поддержку через ReactElement API и JSX
      </p>
      <h1 class="font-bold">33. Что такое события указателя (Pointer Events)?</h1>
      <p>
        События указателя (pointer events) похожи на события мыши (mousedown, mouseup и т.д.), но не зависят от устройства (мышь, стилус, прикосновения и т.д.). Это позволяет избежать реализации функционала для каждого отдельного устройства. Рассматриваемый API работает также, как существующие обработчики событий. События указателя добавляются к
        React-компонентам в качестве атрибутов с колбеком, принимающим событие. Внутри колбека происходит обработка этого события.
      </p>
      <h1 class="font-bold">34. Что такое инверсия наследования (Inheritance Inversion)?</h1>
      <p>Инверсия наследования (inheritance inversion) - это HOC, который выглядит следующим образом</p>
      <code
        >const inheritanceInversionHOC = (WrappedComponent) => { <br />
        return class extends WrappedComponent { <br />
        render() { <br />
        return super.render() <br />
        } <br />
        } <br />
        }</code
      >
      <p>
        Мы возвращаем класс, расширяющий WrappedComponent. Данная техника называется инверсией наследования, поскольку вместо расширения некоторого класса-усилителя (enhancer) с помощью WrappedComponent, последний сам пассивно расширяется. Отношения между ними напоминают инверсию. Инверсия наследования предоставляет HOC доступ к экземпляру
        WrappedComponent. Это означает, что мы можем использовать state, props, методы жизненного цикла и даже метод render данного компонента.
      </p>
      <h1 class="font-bold">35. Как в React реализовать двустороннее связывание данных?</h1>
      <p>Двустороннее связывание данных с помощью хуков</p>
      <p>import React, { useState } from 'react'</p>
      <h1 class="font-bold">36. Разница между классовым и функциональным компонентами?</h1>
      <p>
        Классовые компоненты Для создания классовых компонентов используются классы ES6, расширяющие класс React.Component. Их часто называют компонентами с состоянием, поскольку в них реализуется логика поведения на основе некоторого состояния. Внутри классов могут использоваться методы жизненного цикла, например, componentDidMount. Принимают
        props и имеют к ним доступ через this.props. Могут содержать refs (ссылки, рефы) на нижележащие DOM-узлы. Могут использовать такие техники улучшения производительности, как shouldComponentUpdate() и PureComponent
      </p>
      <p>
        Функциональные компоненты Функциональные компоненты - это обычные функции JavaScript. Чаще всего, они представлены в форме стрелочных функций, но их вполне можно создавать и с помощью ключевого слова function. Их часто называют компонентами без состояния, которые просто принимают данные и отображают их в некоторой форме, поэтому они, в
        основном, отвечают за рендеринг UI (так было до появления хуков). В них нельзя использовать методы жизненного цикла, например, componentDidMount (в настоящее время хуки предоставляют альтернативы почти всем методам жизненного цикла). У них нет метода render. Как правило, они отвечают за UI и форму представления данных (например, компонент
        кнопки). Принимают и используют пропы. Им следует отдавать предпочтение в случаях, когда не требуется работать с состоянием (так было до появления хуков).
      </p>
      <h1 class="font-bold">37. Разница между useEffect() и componentDidMount()?</h1>
      <p>
        В React при использовании классовых компонентов мы получаем доступ к методам жизненного цикла (таким как componentDidMount, componentDidUpdate и т.д.). В функциональных компонентах альтернативой методам жизненного цикла являются хуки. componentDidMount() и useEffect() запускаются после монтирования компонента. Тем не менее, useEffect()
        вызывается после отображения на экране результатов рендеринга. Это означает, что мы можем получить мерцание (flicker) в случае, когда необходимо прочитать DOM и синхронно обновить состояние для получения нового UI.
      </p>
      <h1 class="font-bold">38. Преимущества хуков?</h1>
      <ul>
        <li>С ними легче работать, их легче тестировать (как отдельные функции компонентов), они делают код чище, улучшают его читаемость - сложная логика может быть вынесена в "кастомный" хук.</li>
        <li>Позволяют разделять сложную логику на маленькие функции, используемые внутри компонентов.</li>
        <li>Повышают возможность повторного использования кода.</li>
        <li>Позволяют распределять логику между компонентами через пользовательские хуки.</li>
        <li>Являются более податливыми к перемещениям в дереве компонентов.</li>
      </ul>
      <h1 class="font-bold">39. Недостатки хуков?</h1>
      <ul>
        <li>Правили или ограничения на их использование</li>
        <li>Не покрывают getSnapshotBeforeUpdate и componentDidCatch</li>
        <li>Проблемы с перфомансом при неправильном использовании</li>
      </ul>
      <h1 class="font-bold">40. Правила (ограничения) использования хуков?</h1>
      <ul>
        <li>Хуки вызываются только на верхнем уровне (top-level) компонента. Они НЕ вызываются внутри циклов, условных конструкций, внутри стандартных функций javascript.</li>
        <li>Хуки можно вызывать только из функциональных компонентов React, либо из других хуков.</li>
      </ul>
      <h1 class="font-bold">41. Что такое поднятие состояния вверх (Lifting State Up)?</h1>
      <p>В React совместное использование состояния достигается перемещением его до ближайшего предка компонентов, которым оно требуется. Это называется «подъём состояния».</p>
      <h1 class="font-bold">42. Что делает метод shouldComponentUpdate?</h1>
      <p>shouldComponentUpdate() возвращает логическое значение, определяющее должен ли React продолжать рендеринг компонента. Значением по умолчанию является true.</p>
      <h1 class="font-bold">43. Разница между createElement() и cloneElement()?</h1>
      <p>createElement мы получаем из JSX и его React использует для создания элементов (объектное представление некоторого интерфейса). cloneElement используется для клонирования элемента и отправки ему новых параметров.</p>
      <h1 class="font-bold">44. Что такое useReducer()?</h1>
      <p>
        useReducer - это хук, принимающий функцию-редуктор и начальное состояние приложения в качестве параметров и возвращающий текущее состояние и диспетчер (dispatcher) для отправки (dispatch) операций для обновления состояния. Несмотря на то, что useState - это базовый хук, а useReducer - продвинутый, на самом деле useState() реализован с
        помощью useReducer(). Это означает, что useReducer() - это примитив, который может использоваться во всех случаях использования useState().Сначала мы определяем начальное состояние и редуктор. Затем передаем их в useReducer(). Хук возвращает текущее значение состояния и диспетчер, который используется для обновления состояния. Когда
        пользователь нажимает на кнопку, происходит отправка определенной операции в редуктор, который обновляет счетчик на основе операции. Мы может определять столько операций, сколько требуется нашему приложению.
      </p>
      <h1 class="font-bold">45. Как реализовать однократное выполнение операции при начальном рендеринге?</h1>
      <p>Для этого можно использовать метод жизненного цикла componentDidMount в классовом компоненте:</p>
      <p>Любые операции, определенные в componentDidMount(), будут выполнены только один раз при монтировании компонента. Аналогичный функционал можно реализовать с помощью хука useEffect с пустым массивом зависимостей:</p>
      <h1 class="font-bold">46. Что такое распределенный компонент?</h1>
      <p>
        Распределенный компонент (shared component) - это разновидность компонента, который управляет своим внутренним состоянием, а логику рендеринга делегирует другому компоненту. Таким образом, место определения компонента отделяется от места его реализации. Это предоставляет возможность защитить специфическую логику от остального приложения,
        предоставляя "чистый" и выразительный API для потребления (consume) компонентом.
      </p>
      <h1 class="font-bold">47. Расскажите о хуках useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?</h1>
      <p>
        Хук useCallback может использоваться для оптимизации рендеринга функциональных компонентов. Он возвращает мемоизированную версию колбека. Это означает, что такой колбек обновляется только при изменении его зависимостей. Это может быть полезным при передаче колбеков оптимизированным (например, с помощью метода shouldComponentUpdate) дочерним
        компонентам.
      </p>
      <p>
        Хук useMemo может использоваться для оптимизации вычислений, производимых в функциональных компонентах. useMemo() похож на useCallback(), за исключением того, что он принимает любые значения, а не только функции. Он принимает функцию, возвращающую значение, и массив зависимостей. Значение, возвращенное функцией, вычисляется повторно только
        при изменении зависимостей.
      </p>
      <p>Хук useImperativeHandle позволяет кастомизировать значение, передаваемое родительскому компоненту с помощью ref. Имейте ввиду, что императивный код, в котором используются ссылки, является плохой практикой. useImperativeHandle() должен использоваться совместно с forwardRef():</p>
      <p>
        Хук useLayoutEffect запускается после выполнения всех манипуляций с DOM, но до его отрисовки браузером. Это может быть полезным для получения дополнительной информации из DOM (например, получение величины прокрутки или стилей элемента) и использования этой информации для корректировки DOM или запуска повторного рендеринга путем обновления
        состояния. Данный хук предназначен для выполнения тех же задач, которые выполняют методы componentDidMount и componentDidUpdate.
      </p>
      <h1 class="font-bold">48. Как отрендерить HTML код в React-компоненте?</h1>
      <p>
        Свойству innerHTML в DOM браузера соответствует dangerouslySetInnerHTML в React. Как правило, вставка HTML из кода рискованна, так как можно случайно подвергнуть ваших пользователей атаке межсайтового скриптинга. Таким образом, вы можете вставить HTML непосредственно из React используя dangerouslySetInnerHTML и передать объект с ключом
        __html, чтобы напомнить себе, что это небезопасно
      </p>
      <h1 class="font-bold">49. Зачем в setState() нужно передавать функцию?</h1>
      <p>Отправка функции в setState вместо объекта позволит получить вам достоверные значения для state и props компонента</p>
      <h1 class="font-bold">50. Для чего предназначен метод registerServiceWorker() в React?</h1>
      <p>
        React создает сервис-воркера (service worker) без необходимости предварительной настройки из коробки (при использовании шаблона pwa в create-react-app). Сервис-воркер - это веб-API, позволяющий записывать файлы приложения в кеш и возвращать их из него при отсутствии подключения к сети или медленном соединении, что сильно улучшает
        пользовательский опыт, обеспечивая возможность работы приложения в режиме офлайн. Сервис-воркер - это своего рода прокси для HTTP-запросов.
      </p>
      <h1 class="font-bold">51. Чем React Router отличается от обычной маршрутизации?</h1>
      <p>Учитывая что в прилождении есть только 1 index.html при перемешении на другую страницу react отрисовывает нужный компонент</p>
      <h1 class="font-bold">52.Как передавать пропсы в React Router?</h1>
      <p>Есть метод render который принимает props</p>
      <code> render={props => Greeting text="Hello " {...props} />}</code>
      <h1 class="font-bold">53.Что такое Reselect и как он работает?</h1>
      <p>
        Reselect - это простая библиотека для создания мемоизированных, комбинируемых функций-селекторов. Селекторы используются для эффективного вычисления производных данных из хранилища Redux. Селекторы позволяют хранить минимально возможное состояние. Селектор вычисляется повторно только при изменении его аргументов. При изменении не связанных
        с селектором частей дерева компонентов, повторное вычисление селектора не производится.
      </p>
      <h1 class="font-bold">54.Разница между memo и useMemo?</h1>
      <p>Самое главное отличие между useMemo и memo . Это то что первый является hook-ом, а второй HOC-ом, а именно Higher-Order Component или же Компонент Высшего Порядка.</p>
      <h1 class="font-bold">55.Является ли React реактивным?</h1>
      <p>
        React назван так потому, что реагирует на изменения состояния компонентов. Все же он делает это не реактивно, а, скорее, по графику – отсюда появилась шутка, что React следовало бы назвать Schedule. Однако, если не углубляться внутрь фреймворка, то все что мы видим – это как React реагирует на обновление компонента и автоматически
        отображает его изменения в дереве документа. Помните, что входными данными для render() являются свойства (props) и внутреннее состояние, которое может быть обновлено в любое время. Когда для render меняются входные данные, меняется и результат ее выполнения. React.js ведет запись жизненного цикла компонента. Когда React.js видит, что один
        рендер отличается от другого, он переводит разницу между своим виртуальным представлением в операции с DOM API, которые будут отрисованы в документе.
      </p>
    </div>
    <script src="app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>

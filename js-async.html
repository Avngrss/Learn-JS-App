<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ассинхронный JS</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,500;1,600&display=swap" rel="stylesheet" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg" style="background-color: #e3f2fd">
      <div class="container">
        <a class="navbar-brand" href="index.html">
          <img class="img-fluid" src="img/js.png" alt="JS" width="50" height="50" />
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
          <ul class="navbar-nav">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Методы </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="string.html">Строк</a></li>
                <li><a class="dropdown-item" href="array.html">Массивов</a></li>
                <li><a class="dropdown-item" href="#">Обьетов</a></li>
              </ul>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="js-sobesed.html" role="button" data-bs-toggle="dropdown" aria-expanded="false"> Собеседование </a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="js-sobesed.html">по JS</a></li>
                <li><a class="dropdown-item" href="Js-in-brouser.html">по браузерному JS</a></li>
                <li><a class="dropdown-item" href="js-async.html">по асинхронному JS</a></li>
                <li><a class="dropdown-item" href="react.html">React</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#"> Задачи </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <h1 class="font-bold">1.Разница между синхронными и асинхронными функциями?</h1>
      <p>
        Синхронные функции являются блокирующими, в то время как асинхронные нет. Когда JS натыкается на синхронную функцию он блокирует все операции прежде чем данная функция будет выполнена, поэтому набор таких функций выполняются одна за другой. Асинхронные функции не блокируют дальнейшее выполнения скрипта. Обычно такие функции принимают в
        качестве аргумента коллбек которая будет выполнена как только будет выполнена ассинхронная и которая сможет обратотать полученный результат
      </p>
      <h1 class="font-bold">2.Что такое AJAX?</h1>
      <p>
        AJAX (аббревиатура от «Asynchronous Javascript And Xml») – технология обращения к серверу без перезагрузки страницы. За счёт этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп. Несмотря на то, что в названии технологии присутствует буква X (от слова XML), использовать XML вовсе не обязательно. Под
        AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.
      </p>
      <h1 class="font-bold">3.Что такое цикл событий (event loop) и как он работает?</h1>
      <p>
        С помощью механизма Event Loop (Цикл событий) становится возможным выполнять асинхронный код в JavaScript. Event Loop - это специальный механизм на уровне движка js, который координирует работу трёх сущностей: Call Stack (стэк вызовов), Web API (API, предоставляемый браузером), Callback Queue (очередь колбэков). Работают они следующим
        образом: движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в Call Stack. Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, setTimeout(), обработчик событий,
        сетевой запрос и т.д., то на помощь приходит браузер со своим Web API (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может). Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция уходит из стэка вызовов.
      </p>
      <h1 class="font-bold">4.Что такое same-origin policy в контексте JavaScript?</h1>
      <p>
        Same-origin policy (принцип одинакового источника) не позволяет JS выполнять запросы за границами домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой
        страницы.
      </p>
      <h1 class="font-bold">5.Разница между микро и макрозадачами в event loop?</h1>
      <p>Разница между ними в том, что у микрозадач есть приоритет перед макрозадачами. Они выполняются только после того, как выполнились все микрозадачи. Event loop переходит в очередь макрозадач — и затем снова после макрозадачи выполняются все микро-. И так по кругу, пока Event queue не опустеет.</p>
      <h1 class="font-bold">6.Расскажите о queueMicrotask?</h1>
      <p>
        queueMicrotask() добавляет переданную функцию в очередь микрозадач. Функции в этой очереди выполняются одна за другой (FIFO: First in First Out) — когда текущая функция выполнилась, запускается следующая функция в очереди. Все микрозадачи в очереди будут выполнены только после того, как текущий стек вызовов окажется пустым, но перед
        выполнением следующей макрозадачей. Если вернуться к сравнению с setTimeout(), то передаваемые в него функции этого относятся к макрозадачам. Каждая из них будет взята из очереди задач, после того как управление передастся циклу событий. Поэтому, если вызвать queueMicrotask() после setTimeout(), или наоборот — функция, переданная в
        queueMicrotask(), начнёт своё исполнение первой.
      </p>
      <h1 class="font-bold">7.Что такое промисы (Promises)?</h1>
      <p>
        Объект Promise используется для отложенных и асинхронных вычислений.Promise(Обещание) — это объект который содержит будущее значение асинхронной операции. Например, если вы запрашиваете некоторые данные с сервера, промис обещает нам получить эти данные, которые мы сможем использовать в будущем.Вначале промис имеет статус pending
        ("ожидание"), затем – одно из: fulfilled ("выполнено успешно") или rejected ("выполнено с ошибкой").
      </p>
      <ul>
        <li>Pending - Промис ожидает, если результат не готов. То есть, ожидает завершение чего-либо (например, завершения асинхронной операции).</li>
        <li>Fulfilled - Промис решен, если результат доступен. То есть, что-то завершило свое выполнение(например, асинхронная операция) и все прошло успешно.</li>
        <li>Rejected - Промиc отклонен, если произошла ошибка в процессе выполнения.</li>
      </ul>
      <p>
        Объект Promise создается при помощи ключевого слова new и своего конструктора. Конструктор Промисов принимает один аргумент, обратный вызов, также известный как исполнительная функция⚙️, которая принимает 2 обратных вызова, resolve и reject. Исполнительная функция выполняется сразу же после создания промиса. Промис становится выполненным
        при помощи вызова resolve(), а отклоненным при помощи reject().
      </p>
      <code>const promise = new Promise((resolve, reject) => { if (allWentWell) { resolve('Все прошло отлично!') } else { reject('Что-то пошло не так') } })</code>
      <p>resolve() и reject() принимают один аргумент, который может быть строкой, числом, логическим выражением, массивом или объектом. Чтобы снабдить функцию функционалом обещаний, нужно просто вернуть в ней объект Promise:</p>
      <code>function myAsyncFunction(url) { return new Promise((resolve, reject) => { //код функции }) }</code>
      <p>Промисы используются при помощи методов then() и catch(). then Метод then используется для запуска функций при положительном и отрицательном результате промиса.</p>
      <p>Для отлова ошибок используется метод catch. Его можно использовать вместо метода then для вывода сообщений об ошибке.</p>
      <h1 class="font-bold">8.Плюсы и минусы использовании Ajax?</h1>
      <p>Преимущества использования технологии ajax:</p>
      <ul>
        <li>Экономия трафика. Использование AJAX позволяет значительно, сократить трафик при работе с веб-приложением, благодаря тому, что часто вместо загрузки всей страницы достаточно, загрузить только небольшую изменившуюся час</li>
        <li>
          Уменьшение нагрузки на сервер. AJAX позволяет несколько снизить нагрузку на сервер, например, в Gmail при отмеченных прочитанных письмах, серверу достаточно внести изменения в базу данных и отправить клиентскому скрипту сообщение об успешном выполнении операции, вместо необходимости повторно создавать страницу и отсылать ее клиенту.
        </li>
        <li>Увеличение реакции интерфейса. Поскольку нужно загрузить только изменившуюся часть, то пользователь видит результат своих действий быстрее.</li>
      </ul>
      <p>Недостатки технологии ajax:</p>
      <ul>
        <li>Интеграция со стандартными инструментами браузера. Динамически создаваемые страницы не регистрируются браузером в истории посещения страниц, поэтому не работает кнопка «Назад» предоставляющая пользователям возможность вернуться к просмотренным ранее страницам.</li>
        <li>Динамически загружаемое содержание недоступно поисковикам. Поисковые машины не могут выполнять JavaScript, поэтому разработчики должны позаботиться об альтернативных способах доступа к содержимому сайта.</li>
        <li>Не работает без JavaScript</li>
      </ul>
      <h1 class="font-bold">9.Подходы при работе с асинхронным кодом?</h1>
      <p>Callback, promise , async/await</p>
      <h1 class="font-bold">10.Преимущества использовании промисов вместо колбэков?</h1>
      <p>Преимущества</p>
      <ul>
        <li>Помогает избежать “callback hell”, который может быть нечитаемым.</li>
        <li>Упрощает написание последовательного удобочитаемого асинхронного кода с помощью then().</li>
        <li>Упрощает написание параллельного асинхронного кода с помощью Promise.all().</li>
      </ul>
      <p>Недостатки</p>
      <ul>
        <li>Чуть более сложный код.</li>
        <li>В старых браузерах, где не поддерживается ES2015, нужно загрузить полифил, чтобы их использовать.</li>
      </ul>
      <h1 class="font-bold">11.Что такое callback-функция? Что такое Callback Hell?</h1>
      <p>Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия. которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback — функция обратного вызова).</p>
      <h1 class="font-bold">12.Что такое async/await?</h1>
      <p>Начнём с ключевого слова async. Оно ставится перед функцией. У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.</p>
      <p>Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.</p>
      <h1 class="font-bold">13. Разница между Promise.all(), Promise.any() и Promise.race()?</h1>
      <p>Функция Promise.all() возвращает единый объект Promise, который объединяет набор промисов.Функция Promise.all() позволяет объединить несколько промисов и выполнять их параллельно, но как единое целое.</p>
      <p>Функция Promise.race() также принимает несколько промисов, только возвращает первый завершенный промис (вне зависимости завершился от успешно или с ошибкой)</p>
      <p>Функция Promise.any() принимает несколько промисов и возвращает первый успешно завершившийся промис</p>
      <h1 class="font-bold">14. Расскажите про статический метод .allSettled()?</h1>
      <p>
        Метод allSettled() — это один из статических методов объекта Promise. Его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения. Promise.allSettled() очень похож на метод Promise.all(), но работает немного по-другому. В отличие от Promise.all(), Promise.allSettled() ждёт выполнения всех промисов, при
        этом неважно, завершились они успешно или с ошибкой. Promise.allSettled() принимает итерируемую коллекцию промисов (чаще всего — массив) и возвращает новый промис, который будет выполнен, когда будут выполнены все переданные промисы. Полученный промис содержит массив результатов выполнения всех переданных промисов, сохраняя порядок
        оригинального массива, но не порядок выполнения.
      </p>
      <h1 class="font-bold">15. Проблемы при использовании callback-функций?</h1>
      <p>Считается устаревшим подходом. Первая проблема callback hell, ошибки обратного вызова - это ошибки которые могут возникнуть в самих callback функциях и могут привести к непредсказуемому поведению в программе</p>
      <h1 class="font-bold">16. Как выполнить несколько асинхронных операций последовательно?</h1>
      <p>Использование Promise и цепочек из then</p>
      <p>использование async/await</p>
      <h1 class="font-bold">17. Какие проблемы может вызвать неправильное использование асинхронности в JavaScript?</h1>
      <ul>
        <li>Потеря контекста - это когда this функции теряется в асинхронной функции. Решается привязкой через bind или стрелочной функцией</li>
        <li>Callback hell. решение использование promise или async/await</li>
        <li>Утечки памяти - пробелма когда ссылки на неуправляемые обьекты приводят к увеличению использованию памяти и ухудшению производительности. Решается правильным удалением неиспользуемых ссылок или ресурсов</li>
        <li>Недостаточная производительность - это когда использование Ассинхронности приводит к замедлению работы приложения. Решается использованием Ассинхронности там где это необходимо</li>
      </ul>
    </div>
    <script src="app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
